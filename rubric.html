<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<title>QPED O4 - Rubric</title>
		<link rel="stylesheet" href="style.css">
		<script language="javascript" type="text/javascript">
		const FEATURES = JSON.parse(
`[
   {
      "name":"Modularity",
      "key":"modularity",
      "level":"advanced",
      "fail_examples":[
         {
            "key":"1",
            "desc":"Unclear structure",
            "desc_long":"Project structure is unclear since the code is not organized in coherent packages, folders, files, etc."
         },
         {
            "key":"2",
            "desc":"Unrelated tasks in functions/low cohesion",
            "desc_long":"Most of the classes and functions perform many unrelated tasks and/or their bodies are large."
         },
         {
            "key":"3",
            "desc":"High degree of coupling",
            "desc_long":"Modules (classes, objects) depend heavily on each other to function properly. Modules are not very well encapsulated."
         },
         {
            "key":"4",
            "desc":"No information hiding",
            "desc_long":"The visibility of methods/fields is not well thought out (fields should usually be private)."
         }
      ],
      "pass_examples":[
         {
            "key":"1",
            "desc":"Clear structure",
            "desc_long":"Project structure is clear since the code is organized in coherent packages, folders, files, etc."
         },
         {
            "key":"2",
            "desc":"Clear-cut scope of classes and functions/high cohesion",
            "desc_long":"Most of the classes and functions perform a limited set of tasks and their bodies are limited in length."
         },
         {
            "key":"3",
            "desc":"Low degree of coupling",
            "desc_long":"Modules are well encapsulated. They only depend on each other if necessary."
         },
         {
            "key":"4",
            "desc":"Information hiding",
            "desc_long":"The modifiers for visibility are very well thought out. Each module (class, method, package) only has access to intended methods."
         }
      ]
   },
   {
      "name":"Data Types",
      "key":"data_types",
      "level":"basic",
      "fail_examples":[
         {
            "key":"1",
            "desc":"Wrong data types",
            "desc_long":"The choice of some data types is wrong, e.g., an integer is used when a boolean is more suitable."
         },
         {
            "key":"2",
            "desc":"Unnecessary complex types",
            "desc_long":"Unnecessary use of more complex types. E.g., the result of an integer computation is stored in a double variable."
         },
         {
            "key":"3",
            "desc":"Unnecessary type casts",
            "desc_long":"Manually casting types unnecessarily. E.g., (Object) \\\"Hello World!\\\"."
         },
         {
            "key":"4",
            "desc":"Confusing implicit casting",
            "desc_long":"Implicitly using toString() when not intended."
         }
      ],
      "pass_examples":[
         {
            "key":"1",
            "desc":"Appropriate data types",
            "desc_long":"The choice of the data types is correct, e.g., an integer is used when an integer is necessary"
         },
         {
            "key":"2",
            "desc":"Appropriate data structures",
            "desc_long":"Complex data structures are only used when needed, e.g., ArrayList instead of array when size varies dynamically. No unnecessary coercion or casts necessary."
         }
      ]
   },
   {
      "name":"Readability",
      "key":"readability",
      "level":"basic",
      "fail_examples":[
         {
            "key":"1",
            "desc":"Wrong indentation",
            "desc_long":"Indentation of code is not up to code conventions."
         },
         {
            "key":"2",
            "desc":"Broken lines of code",
            "desc_long":"Code lines are broken badly. They either contain too much code or line-breaks are unnecessarily placed."
         },
         {
            "key":"3",
            "desc":"Parentheses wrongly placed",
            "desc_long":"Parentheses are placed in ways contrary to code conventions."
         },
         {
            "key":"4",
            "desc":"Poor naming",
            "desc_long":"Some names appear unreadable, meaningless, misleading and/or do not meet naming conventions."
         },
         {
            "key":"5",
            "desc":"Bad comments",
            "desc_long":"Comments are usually missing or only explain obvious issues, such as what the code statement is doing."
         }
      ],
      "pass_examples":[
         {
            "key":"1",
            "desc":"Correct indentation",
            "desc_long":"Indentation conforms to the code conventions."
         },
         {
            "key":"2",
            "desc":"Considered lines of code",
            "desc_long":"Complex lines of code are broken up in smaller, easier to understand and coherent chunks."
         },
         {
            "key":"3",
            "desc":"Correctly placed parentheses",
            "desc_long":"Placement of parentheses conforms to the code conventions."
         },
         {
            "key":"4",
            "desc":"Good names",
            "desc_long":"Meaningful identifiers which meet naming conventions are used as variables, functions and class names."
         },
         {
            "key":"5",
            "desc":"Useful comments",
            "desc_long":"Comments explain tricky or important decisions."
         }
      ]
   },
   {
      "name":"DRY principle",
      "key":"dry_principle",
      "level":"basic",
      "fail_examples":[
         {
            "key":"1",
            "desc":"Repeated code",
            "desc_long":"Repeat snippets of code quite often."
         },
         {
            "key":"2",
            "desc":"Magic numbers",
            "desc_long":"Frequently used numbers or Strings with a specific meaning and/or derived values are hard-coded (magic numbers)."
         }
      ],
      "pass_examples":[
         {
            "key":"1",
            "desc":"Helper functions are used",
            "desc_long":"Helper functions are used in order to reuse code."
         },
         {
            "key":"2",
            "desc":"Use of constants",
            "desc_long":"Symbolic (named) constants are used and they are kept in a common place."
         }
      ]
   },
   {
      "name":"Flow",
      "key":"flow",
      "level":"advanced",
      "fail_examples":[
         {
            "key":"1",
            "desc":"Obscured flow",
            "desc_long":"Code order of blocks obscures intuition of assignment."
         },
         {
            "key":"2",
            "desc":"Unnecessary branching",
            "desc_long":"A conditional statement is used when instead the if-predicate should be used in an expression. For example: if(x) return true else return false; instead of return x;"
         },
         {
            "key":"3",
            "desc":"Unnecessary nesting",
            "desc_long":"Nested if-statements are used when not strictly necessary or useful for readability. E.g., if(a) if(b) instead of if(a && b)."
         },
         {
            "key":"4",
            "desc":"Switch/if often mixed up",
            "desc_long":"Multiple if-blocks are frequently used instead of using switch or a switch statement is used for binary decisions."
         }
      ],
      "pass_examples":[
         {
            "key":"1",
            "desc":"Simple flow",
            "desc_long":"Code order of blocks corresponds to intuition of assignment."
         },
         {
            "key":"2",
            "desc":"Only necessary branches",
            "desc_long":"Code only branches when necessary, not when possible."
         },
         {
            "key":"3",
            "desc":"Only necessary nesting",
            "desc_long":"Nested conditionals are only used when necessary."
         },
         {
            "key":"4",
            "desc":"Correct use of Switch/if",
            "desc_long":"Switch is used instead of multiple if-blocks. If-statements are used for binary decisions."
         }
      ]
   },
   {
      "name":"API Documentation",
      "key":"api_documentation",
      "level":"advanced",
      "fail_examples":[
         {
            "key":"1",
            "desc":"Class Documentation is missing",
            "desc_long":"Author, version and goal of the class are missing."
         },
         {
            "key":"2",
            "desc":"Attributes not well documented",
            "desc_long":"Incorrect or insufficient documentation of attributes."
         },
         {
            "key":"3",
            "desc":"Missing method documentation",
            "desc_long":"Documentation of methods is flawed. Either pre- and post-conditions are missing or the method is not well explained (including a summarizing first sentence)."
         },
         {
            "key":"4",
            "desc":"Incorrect method signature documentation",
            "desc_long":"The documentation for the signature of a method is flawed. Either parameters are not well documented (wrong position, bad explanation) or exceptions are not documented."
         }
      ],
      "pass_examples":[
         {
            "key":"1",
            "desc":"Classes are well documented",
            "desc_long":"One or more of author, version and the goal of the class are mentioned within the documentation."
         },
         {
            "key":"2",
            "desc":"Attributes documented",
            "desc_long":"Documentation about attributes is correct."
         },
         {
            "key":"3",
            "desc":"Method functionality documented",
            "desc_long":"Documentation about methods is correct. It contains a meaningful first sentence and documentation of pre- post conditions."
         },
         {
            "key":"4",
            "desc":"Documentation of a methods signature is correct.",
            "desc_long":"Parameters as well as possible exceptions are mentioned and well documented."
         }
      ]
   },
   {
      "name":"Correctness",
      "key":"correctness",
      "level":"basic",
      "fail_examples":[
         {
            "key":"1",
            "desc":"Wrong file format",
            "desc_long":"The file format of the submitted code is not in the correct format. E.g., a PDF is used instead of a Java file."
         },
         {
            "key":"2",
            "desc":"Not compiling/running",
            "desc_long":"The code does not compile or does not run without errors."
         },
         {
            "key":"3",
            "desc":"Specifications not met",
            "desc_long":"The program does not meet some of the specifications in the assignment."
         }
      ],
      "pass_examples":[
         {
            "key":"1",
            "desc":"Functions properly",
            "desc_long":"The program conforms to the specifications provided by the assignment."
         },
         {
            "key":"2",
            "desc":"Correct results",
            "desc_long":"The program produces correct results for correct inputs."
         }
      ]
   },
   {
      "name":"Robustness",
      "key":"robustness",
      "level":"advanced",
      "fail_examples":[
         {
            "key":"1",
            "desc":"No error handling",
            "desc_long":"Errors or abnormal conditions are not all handled."
         },
         {
            "key":"2",
            "desc":"Edge cases not handled",
            "desc_long":"Edge cases are mostly ignored within the implementation. E.g., empty strings, empty lists, and so on."
         },
         {
            "key":"3",
            "desc":"No parameter validation",
            "desc_long":"Validation of parameters is mostly missing. E.g., it is possible to pass negative numbers to a function over natural numbers."
         }
      ],
      "pass_examples":[
         {
            "key":"1",
            "desc":"Errors handled properly",
            "desc_long":"The program reacts properly to abnormal conditions and erroneous inputs."
         },
         {
            "key":"2",
            "desc":" Edge cases handled",
            "desc_long":"Edge cases are handled within the method. E.g., empty strings, empty lists, etc. are handled within the code."
         },
         {
            "key":"3",
            "desc":"Parameters are validated",
            "desc_long":"Parameters are validated. It is not possible to enter forbidden input into a method."
         }
      ]
   },
   {
      "name":"Test Traceability",
      "key":"test_traceability",
      "level":"advanced",
      "fail_examples":[
         {
            "key":"1",
            "desc":"Test scenario clear",
            "desc_long":"The test scenario is not prepared clearly or preparation is mixed with the test execution."
         },
         {
            "key":"2",
            "desc":"Tests multiple units",
            "desc_long":"A test asserts properties of multiple methods (e.g., method calls and assertions alternate a lot)."
         },
         {
            "key":"3",
            "desc":"Not traceable",
            "desc_long":"It is not easy to see a relation between the specifications in the assignment and tests."
         },
         {
            "key":"4",
            "desc":"Bad test naming",
            "desc_long":"The names of the tests do not clearly describe the test case."
         }
      ],
      "pass_examples":[
         {
            "key":"1",
            "desc":"Test scenario clear",
            "desc_long":"The creation of the context in which the tested functionality is performed is meaningful."
         },
         {
            "key":"2",
            "desc":"Tests one unit",
            "desc_long":"One test asserts properties of just one method."
         },
         {
            "key":"3",
            "desc":"Traceable",
            "desc_long":"For each test the underlying requirements are easily recognizable."
         },
         {
            "key":"4",
            "desc":"Good test naming",
            "desc_long":"The names of tests clearly describe the test cases."
         }
      ]
   },
   {
      "name":"Test Completeness",
      "key":"test_completeness",
      "level":"advanced",
      "fail_examples":[
         {
            "key":"1",
            "desc":"Insufficient specification coverage",
            "desc_long":"Some specifications are not tested at all or are tested insufficiently."
         },
         {
            "key":"2",
            "desc":"Insufficient coverage for the happy path",
            "desc_long":"The most common path through a program is not sufficiently tested. E.g., there are common branches that get ignored in testing."
         },
         {
            "key":"3",
            "desc":"Insufficient coverage of edge cases",
            "desc_long":"Some or all edge cases get ignored in testing. E.g.,  or empty Strings are ignored in testing."
         },
         {
            "key":"4",
            "desc":"Insufficient coverage of exceptional path",
            "desc_long":"Less frequent branches are not sufficiently tested."
         },
         {
            "key":"5",
            "desc":"Thrown exceptions are not tested",
            "desc_long":"A method that is supposed to throw an exception in a certain case is not tested to do so."
         },
         {
            "key":"6",
            "desc":"Incorrect assertions",
            "desc_long":"The expected values in assertions are wrong or conditions are too weak, such that incorrect programs pass the tests."
         }
      ],
      "pass_examples":[
         {
            "key":"1",
            "desc":"Sufficient specification coverage",
            "desc_long":"All specifications of the program are tested properly and sufficiently."
         },
         {
            "key":"2",
            "desc":"Sufficient coverage happy path",
            "desc_long":"The most common path through a program is sufficiently tested."
         },
         {
            "key":"3",
            "desc":"Sufficient coverage of edge cases",
            "desc_long":"All edge cases are tested for every method within the program."
         },
         {
            "key":"4",
            "desc":"Sufficient coverage of exceptional path",
            "desc_long":"Infrequent or exceptional paths through the program are tested sufficiently."
         },
         {
            "key":"5",
            "desc":"Thrown exceptions are tested",
            "desc_long":"It is tested if every method that throws exceptions does indeed throw the exception in question in the correct situations."
         },
         {
            "key":"6",
            "desc":"Correct Assertions",
            "desc_long":"The expected values in assertions are correct and strong enough. Only correct programs can pass the tests."
         }
      ]
   },
   {
      "name":"PG - Extern - Design",
      "key":"pg_external_design",
      "level":"procedural_guidance",
      "fail_examples":[
         
      ],
      "pass_examples":[
         {
            "key":"1",
            "desc":"Suitable entities and types.",
            "desc_long":"Proposing suitable classes, methods, parameter and return types for the API."
         }
      ]
   },
   {
      "name":"PG - Extern - Specification",
      "key":"pg_external_specification",
      "level":"procedural_guidance",
      "fail_examples":[
         
      ],
      "pass_examples":[
         {
            "key":"1",
            "desc":"Informal pre- and postconditions",
            "desc_long":"Giving informal preconditions and postconditions for the methods in the API in terms of the application domain."
         },
         {
            "key":"2",
            "desc":"Specification for robustness",
            "desc_long":"Providing robustness by specifying the desired behavior in case satisfying the postcondition is not possible (e.g. throwing exceptions, asking for user input, using default values)."
         },
         {
            "key":"3",
            "desc":"Well-named subspecifications",
            "desc_long":"Organizing the case analysis in the specification into well-named subspecifications."
         },
         {
            "key":"4",
            "desc":"Completeness of subcontracts",
            "desc_long":"Completeness of subcontracts"
         }
      ]
   },
   {
      "name":"PG - Extern - Tests",
      "key":"pg_external_tests",
      "level":"procedural_guidance",
      "fail_examples":[
         
      ],
      "pass_examples":[
         {
            "key":"1",
            "desc":"Test coverage",
            "desc_long":"Proposing a sufficient number of test cases to cover all the cases in the specification, including both typical and edge values."
         }
      ]
   },
   {
      "name":"PG - Intern - Analaysis",
      "key":"pg_internal_analysis",
      "level":"procedural_guidance",
      "fail_examples":[
         
      ],
      "pass_examples":[
         {
            "key":"1",
            "desc":"Data types",
            "desc_long":"Being able to answer questions about the analysis considerations in terms of the choices of data types and the problem decomposition. "
         },
         {
            "key":"2",
            "desc":"Analysis considerations",
            "desc_long":"If asked for: a description of the analysis considerations."
         }
      ]
   },
   {
      "name":"PG - Intern - Design",
      "key":"pg_internal_design",
      "level":"procedural_guidance",
      "fail_examples":[
         
      ],
      "pass_examples":[
         {
            "key":"1",
            "desc":"Hhigh cohesion/low coupling, separation",
            "desc_long":"Decomposing the problem into classes and methods with high cohesion/low coupling and clear responsibilities."
         },
         {
            "key":"2",
            "desc":"Types of the class attributes",
            "desc_long":"Deciding on type of the class attributes necessary for realizing the class’s responsibilities."
         },
         {
            "key":"3",
            "desc":"Names reflect purposes",
            "desc_long":"Coming up with names for classes, attributes, (private) methods, parameters (name and type of) that reflect their purpose."
         }
      ]
   },
   {
      "name":"PG - Intern - Specification",
      "key":"pg_internal_specification",
      "level":"procedural_guidance",
      "fail_examples":[
         
      ],
      "pass_examples":[
         {
            "key":"1",
            "desc":"Invariants",
            "desc_long":"Providing a representation invariant that describes the relationship between application domain concepts and data types."
         },
         {
            "key":"2",
            "desc":"Less on domain knowledge",
            "desc_long":"Translating the external method specifications, using the representation invariant, into versions that rely less on domain knowledge."
         },
         {
            "key":"3",
            "desc":"Specifications for internal methods/classes",
            "desc_long":"Providing specifications for private methods and methods of helper-objects introduced in the internal design."
         }
      ]
   },
   {
      "name":"PG - Intern - Tests",
      "key":"pg_internal_tests",
      "level":"procedural_guidance",
      "fail_examples":[
         
      ],
      "pass_examples":[
         {
            "key":"1",
            "desc":"Grey box tests",
            "desc_long":"Extending the tests of public methods using their internal specification (grey box tests)."
         },
         {
            "key":"2",
            "desc":"Tests for internal methods",
            "desc_long":"Adding tests for the methods introduced in the internal design, i.e. private methods and helper-objects (grey box) ."
         }
      ]
   },
   {
      "name":"PG - Impl - Analysis",
      "key":"pg_implementation_analysis",
      "level":"procedural_guidance",
      "fail_examples":[
         
      ],
      "pass_examples":[
         {
            "key":"1",
            "desc":"Considering re-use",
            "desc_long":"Consideration of the advantages of using library components or to design build own software."
         }
      ]
   },
   {
      "name":"PG - Impl - Design",
      "key":"pg_implementation_design",
      "level":"procedural_guidance",
      "fail_examples":[
         
      ],
      "pass_examples":[
         {
            "key":"1",
            "desc":"Algorithm selection",
            "desc_long":"Deciding on an algorithm that satisfies the specification and exhibits reasonable efficiency."
         },
         {
            "key":"2",
            "desc":"Maintainability",
            "desc_long":"Providing for maintainability through replacing switches by subclassing, avoiding loop exit jumps, avoiding external calls from temporarily corrupt objects, etc."
         }
      ]
   },
   {
      "name":"PG - Impl - Coding",
      "key":"pg_implementation_coding",
      "level":"procedural_guidance",
      "fail_examples":[
         
      ],
      "pass_examples":[
         {
            "key":"1",
            "desc":"Correct algorithm implementation",
            "desc_long":"Providing code that implements the chosen algorithms and does not generate compiler errors or warnings."
         }
      ]
   },
   {
      "name":"PG - Impl - Tests",
      "key":"pg_implementation_tests",
      "level":"procedural_guidance",
      "fail_examples":[
         
      ],
      "pass_examples":[
         {
            "key":"1",
            "desc":"Test coverage",
            "desc_long":"Adding tests to ensure that all code is covered."
         },
         {
            "key":"2",
            "desc":"Tests for code risks",
            "desc_long":"Adding tests to check for risks in the code (e.g. division by zero, overflow, file I/O)."
         },
         {
            "key":"3",
            "desc":"Running all tests.",
            "desc_long":"Running all tests."
         }
      ]
   }
]`
);
		</script>	
		<script language="javascript" type="text/javascript">
		window.addEventListener('load', (event) => {
    load();
});


function Task(name, maxPoints, course, week, differentiation, deliverables, rubricSet, additionalComments, blueprint){

	this.name = name;
	this.maxPoints = maxPoints;
	this.course = course;
    this.week = week;
    this.differentiation = differentiation;
    this.deliverables = deliverables;
	this.rubricSet = rubricSet;
	this.additionalComments = additionalComments;
	this.feedbackSet=[];
	this.blueprint = blueprint;
}

function Deliverable(name,selected){
    this.name = name;
    this.selected = selected;
}

function EnabledFeature(name, weight){
    this.name = name;
    this.weight = weight;
}

/* HTML to Element(s) copied from
 * https://stackoverflow.com/questions/494143/creating-a-new-dom-element-from-an-html-string-using-built-in-dom-methods-or-pro/35385518#35385518
 */
/**
 * @param {String} HTML representing a single element
 * @return {Element}
 */
function htmlToElement(html) {
    var template = document.createElement('template');
    html = html.trim(); // Never return a text node of whitespace as the result
    template.innerHTML = html;
    return template.content.firstChild;
}

/**
 * @param {String} HTML representing any number of sibling elements
 * @return {NodeList} 
 */
function htmlToElements(html) {
    var template = document.createElement('template');
    template.innerHTML = html;
    return template.content.childNodes;
}

function download(filename, text) {
  var element = document.createElement('a');
  element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
  element.setAttribute('download', filename);

  element.style.display = 'none';
  document.body.appendChild(element);

  element.click();

  document.body.removeChild(element);
}

function makeToast(displayText) {
  // Get the snackbar DIV
  var snackbar = document.getElementById("snackbar");
  snackbar.innerHTML = displayText;

  // Add the "show" class to DIV
  snackbar.className = "show";

  // After 3 seconds, remove the show class from DIV
  setTimeout(function(){ snackbar.className = snackbar.className.replace("show", ""); }, 9500);
} </script>	
		<script language="javascript" type="text/javascript">
		const MAX_SCORE = 4;
const scoreInputs = new Map();
const failExInputs = new Map();
const passExInputs = new Map();
const notEnteredInputs = new Map();
const disabledInputs = new Map();
const OK = "OK";
var tasks;
var task;
var textFieldsDirty = false;

window.addEventListener('load', (event) => {
	handleToolTippToggle();
});
function handleLeavePage() {
	if(currentInputDirty()) {
		makeToast("There is unsaved feedback. You can press 'Next Student' to store.");
		return "There is unsaved feedback. You can press 'Next Student' to store. Do you want to leave?";
	}
}

function appendExamples(tr, category, featureKey, examples, examplesMap) {
  const examplesDomElements = [];
  examplesMap.set(featureKey, examplesDomElements);

  const td = htmlToElement('<td/>');
  const ul = htmlToElement('<ul/>');
  td.appendChild(ul);

  examples.forEach(
  example => {
    li = htmlToElement('<li/>');
    ul.appendChild(li);
    
	ulEx = htmlToElement('<ul/>');
    liEx = htmlToElement('<li/>');
    ulEx.appendChild(liEx);
    
    label = htmlToElement('<label/>');
    li.appendChild(label);
	li.appendChild(ulEx);

    input = htmlToElement(`<input type="checkbox" class="${category}_example" id="${featureKey}_${category}_${example.key}" name="${featureKey}_${category}_${example.key}" data-feature-key="${featureKey}" data-category="${category}" data-example-key="${example.key}" onChange="examplesChange('${featureKey}')"/>`);
    label.appendChild(input);
    label.appendChild(htmlToElement(example.desc));
	
	descDiv = htmlToElement('<div/>');
	descDiv.appendChild(htmlToElement(example.desc_long));
	descDiv.className = "descLongDiv";
	liEx.appendChild(descDiv);

    examplesDomElements.push(input);
  });

  tr.appendChild(td);
}

function load() {
  //localStorage.clear();
  let dropArea = document.getElementById('fileDragOverField');
  ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
    dropArea.addEventListener(eventName, preventDefaults, false)
  });
  ['dragenter', 'dragover'].forEach(eventName => {
  dropArea.addEventListener(eventName, highlight, false)
  });

  ['dragleave', 'drop'].forEach(eventName => {
    dropArea.addEventListener(eventName, unhighlight, false)
  });
  dropArea.addEventListener('drop', handleDrop, false);
  let tasksJSON = localStorage.getItem('all_tasks');
  if(tasksJSON == null){
	  localStorage.setItem('all_tasks', JSON.stringify(new Array()));
  }
  tasks = JSON.parse(localStorage.getItem('all_tasks'));
  if(tasks.length==0){
	setTable([], false);
	reset();	
  }
  else{
	setTask(tasks.length - 1);	
	updateTaskList();
  }
  computePoints();

  if(localStorage.grader) {
  	document.getElementById("grader_text").value = localStorage.grader;
  }

  if(localStorage.courseYear) {
  	document.getElementById("course_year_text").value = localStorage.courseYear;
  }
  if(!localStorage.courseRun) {
  	localStorage.courseRun = "1";
  }
  document.getElementById("course_run_text").value = localStorage.courseRun;
}

function handleGraderChange() {
	localStorage.grader = document.getElementById("grader_text").value;
}

function handleCourseYearChange() {
	localStorage.courseYear = document.getElementById("course_year_text").value;
}

function handleCourseRunChange() {
	localStorage.courseRun = document.getElementById("course_run_text").value;
}

function handleTextChange() {
	textFieldsDirty = true;
}

function setTask(index){
	task = tasks[index];

	var enabledFeatureNames = [];
	task.rubricSet.forEach( enabledFeature => {
			enabledFeatureNames.push(enabledFeature.name);
		}
	);

	setTable(enabledFeatureNames,true);
	let selectedTask = document.getElementById("selected_task");
	selectedTask.innerHTML = task.name;
	let taskPoints = document.getElementById("task_points");
	taskPoints.value="0";
	let taskCalcPoints = document.getElementById("task_calc_points");
	taskCalcPoints.value="";
	let taskMaxPoints = document.getElementById("task_max_points");
	taskMaxPoints.value=task.maxPoints;
	reset();
}

function updateTaskList(){
	let taskList = document.getElementById("task_list");
	taskList.innerHTML = "";
	for(let i = 0; i<tasks.length;i++){
		let li = htmlToElement('<li></li>');
		let task = tasks[i];
		li.innerHTML = task.name;
		li.setAttribute("onclick","setTask("+i+");");
		taskList.appendChild(li);
	}
}

function highlight(e) {
  e.target.classList.add('highlight');
}

function unhighlight(e) {
  e.target.classList.remove('highlight');
}

function reset() {
	textFieldsDirty = false;

	for (let domElement of notEnteredInputs.values()) {
		domElement.checked = true;
	}

	for (let domElement of disabledInputs.values()) {
		domElement.checked = false;
	}
	for (let domElements of scoreInputs.values()) {
		domElements[2].checked = true;
	}

	for (let domElements of failExInputs.values()) {
		domElements.forEach( element => element.checked = false);
	}
	
	for (let domElements of passExInputs.values()) {
		domElements.forEach( element => element.checked = false);
	}

	document.getElementById('task_points').value = "0";

	var feedbackField = document.getElementById('feedback_text');
	feedbackField.value = '';
	var additionalComment = document.getElementById('comment_text');
	additionalComment.value = '';
	if(task != undefined){
	let latestFeedback = task.feedbackSet[task.feedbackSet.length-1];
		if(latestFeedback != undefined){
			additionalComment.value = latestFeedback.additionalComment;
			for(let feedback of latestFeedback.feedbackFeature){
				let featurePass = passExInputs.get(feedback.key);
				let featureFail = failExInputs.get(feedback.key);
				for(let improvementPoint of feedback.improvementPoints){
					featureFail[parseInt(improvementPoint)-1].checked = true;
				}
				for(let goodPoint of feedback.goodPoints){
					featurePass[parseInt(goodPoint)-1].checked = true;
				}
				examplesChange(feedback.key);
				computePoints();
			}
		}
	}
}

function FeedbackPerTask(weightedAverageScore, pointsForSolution, feedbackFeature, additionalComment, grader, courseYear, courseRun){
	this.weightedAverageScore = weightedAverageScore;
	this.pointsForSolution = pointsForSolution;
	this.feedbackFeature = feedbackFeature;
	this.additionalComment = additionalComment;
	this.grader = grader;
	this.courseRun = courseRun;
	this.courseYear = courseYear;
	this.timestamp = new Date().toISOString();
	this.reserved1 = "";
	this.reserved2 = "";
	this.reserved3 = "";
}

function FeedbackPerFeature(key, score, scoreWeight, improvementPoints, goodPoints){
	this.key = key;
	this.score = score;
	this.scoreWeight = scoreWeight;
	this.improvementPoints = improvementPoints;
	this.goodPoints = goodPoints;
}

function handleFeedbackButtonClick(){
	textFieldsDirty = true;
	summarizeFeedback(true)
}

function summarizeFeedback(updateTextField){
	var feedbackField = document.getElementById('feedback_text');
	var data = [];
	if(task!=undefined){
		let grader = document.getElementById("grader_text").value;
		if(grader == ""){
			makeToast("Please enter your name in the grader field.")
			return "Enter grader.";
		}
		let courseYear = document.getElementById("course_year_text").value;
		if(courseYear == ""){
			makeToast("Please enter the start year of the course.")
			return "Enter start year.";
		}
		let courseRun = document.getElementById("course_run_text").value;
		if(courseRun == ""){
			makeToast("Please enter the current run of the course.")
			return "Enter run.";
		}
		var feedback = 'This feedback is an auto-generated summary of the rating of your assignmnet according to the rubric. ' +
										'The assignment may have additional grading criteria, which is why your grade may diverge from the computed score. ' +
										'If the grader provides additional feedback, you find this at the bottom.\n\n';

		var enabledFeatureNames = [];
		var totalWeight = 0;
		var weights = new Map();
		task.rubricSet.forEach( enabledFeature => {
			enabledFeatureNames.push(enabledFeature.name);
			totalWeight += enabledFeature.weight;
			weights.set(enabledFeature.name, enabledFeature.weight);
		});
		
		var feedbackFeature = [];

		FEATURES.forEach(
    	element => {
	  		if(enabledFeatureNames.includes(element.key)){
	  			feedback += element.name + '\n';
	  			feedback += '='.repeat(element.name.length) + '\n';
				let score = (getScoreFromRadioButton(element.key) + 1);
				let scoreWeighted = (Math.round((weights.get(element.key) / totalWeight) * 1000) / 10);
	  			feedback += 'Score        : ' + score + ' [1 (fully failed) - 4 (fully passed)]\n';

	  			feedback += 'Score weight : ' + scoreWeighted + '%\n\n';

	  			feedback += 'Points for improvement\n';
	  			feedback += '----------------------\n';
				
				let improvementPoints = [];
				
					failExInputs.get(element.key).forEach( domElement => {
						if (domElement.checked) {
							feedback += '- ';
							element.fail_examples.forEach(example => {
								if (example.key === domElement.dataset.exampleKey) {
									feedback += example.desc_long + '\n';
									improvementPoints.push(example.key);
								}
							});
						}
				  });
				  feedback += '\n';


	  			feedback += 'Good points\n';
	  			feedback += '-----------\n';
				
				let goodPoints = [];

					passExInputs.get(element.key).forEach( domElement => {
						if (domElement.checked) {
							feedback += '+ ';
							element.pass_examples.forEach(example => {
								if (example.key === domElement.dataset.exampleKey) {
									feedback += example.desc_long + '\n';
									goodPoints.push(example.key);
								}
							});
						}
				  });
				  feedback += '\n';
				  
				feedbackFeature.push(new FeedbackPerFeature(element.key, score, scoreWeighted, improvementPoints, goodPoints));

     		 }});
			 
		var weightedAverageScore = computeWeightedScore();
		var pointsForSolution = document.getElementById("task_points").value;

		feedback += "Grading\n";
		feedback += "=======\n";
		feedback += "Weighted average score   : " + weightedAverageScore.toFixed(1) + ' [1 (fully failed) - 4 (fully passed)]\n';
		feedback += "Points for this solution : " + pointsForSolution + " [of " + task.maxPoints + ']\n\n';
		
		feedback += "Additional Comment\n";
		feedback += "==================\n";		
		let additionalComment = document.getElementById("comment_text").value;
		feedback += additionalComment;
		
		var data = new FeedbackPerTask(weightedAverageScore, pointsForSolution, feedbackFeature, additionalComment, grader, courseYear, courseRun);

		if (updateTextField) {
			feedbackField.value = feedback;
		}

		if(task.feedbackSet.length!=0){
			task.feedbackSet[task.feedbackSet.length-1] = data;
		}
		else{
			task.feedbackSet.push(data);
		}
		localStorage.setItem('all_tasks', JSON.stringify(tasks));
	} else {
		feedbackField.value = '';
		makeToast("Please select a task before trying to generate feedback.");
		return "Select a task.";
	}
	return OK;
}

function convertToCSV(object){
	csvObject = convertObjectToCSV(object, "");
	return csvObject[0] + "\n" + csvObject[1];
}

function convertObjectToCSV(object, addString){
	var ret = "";
	var header = "";
	const map = new Map(Object.entries(object));
	for (const [key, value] of map.entries()) {
		if(Array.isArray(value)){
			if(key == "deliverables"){
				const deliverables = convertDeliverablesToCSV(value);
				header+=deliverables[0];
				ret+=deliverables[1];
			}
			else if(key == "rubricSet"){
				const rubricSet = convertRubricSetToCSV(value);
				header+=rubricSet[0];
				ret+=rubricSet[1];
			}
			else if(key == "feedbackSet"){
				const feedbackSet = convertFeedbackSetToCSV(value);
				header+=feedbackSet[0];
				let temp = ret;
				ret = "";
				for(let line of feedbackSet[1]){
					ret+= temp + line + "\n";
				}
			}
			else{
				for(let i = 0; i < value.length; i++){
					let item = value[i];
					if(item!=null){
						csvItem = convertObjectToCSV(item, addString+"_"+i);
						header += csvItem[0];
						ret += csvItem[1];
					}
				}
			}
		}
		else{
			header += key + addString + ";";
			ret+='"'+value+'";';
		}
	}
	return [header,ret];
}

function convertDeliverablesToCSV(deliverables){
	let header = "";
	let ret = "";
	for(let i = 0; i < deliverables.length; i++){
		header+=deliverables[i].name+";";
		ret+=deliverables[i].selected+";";
	}
	return [header,ret];
}

function convertRubricSetToCSV(rubricSet){
	let header = "";
	let ret = "";
	FEATURES.forEach(
		element =>{
			header+=element.key+";";
			ret+=findWeightForFeature(rubricSet, element.key)+";";
		}
	);
	return [header,ret];
}

function convertFeedbackSetToCSV(feedbackSet){
	let header = undefined;
	let ret = [];
	for(let feedback of feedbackSet){
		if (feedback==undefined)
			continue;
		ret.push("");
		let tempHeader = "";	
		const feedbackMap = new Map(Object.entries(feedback));
		for (const [key, value] of feedbackMap.entries()) {
			if(!(key=="key" || Array.isArray(value))){
				if(header==undefined){
					tempHeader+= key +";";
				}
				ret[ret.length-1]+=value+";";
			}
		}
		let feedbackFeatures = [];
		FEATURES.forEach(
			element => {
				feedbackFeatures.push(getFeedbackForFeature(element.key, feedback));
			}
		)
		for(let feedbackFeature of feedbackFeatures){
			const feedbackFeatureMap = new Map(Object.entries(feedbackFeature));
			let headerPrefix = feedbackFeature.key + "_";
			for (const [key, value] of feedbackFeatureMap.entries()) {
				if(!(key=="key" || Array.isArray(value))){
					if(header==undefined){
						tempHeader+= headerPrefix+key +";";
					}
					ret[ret.length-1]+=value+";";
				}
			}
			const examples = getExamplesPerFeature(feedbackFeature.key);

			if(header==undefined){
				tempHeader += headerPrefix + "positive_examples;";
			}

			let goodPoints = "";
			for(let goodPoint of feedbackFeature.goodPoints){
				if (goodPoints.length != 0) {
					goodPoints += ",";
				}
				goodPoints += goodPoint;
			}
			ret[ret.length-1] += goodPoints + ";";

			if(header==undefined){
				tempHeader += headerPrefix + "negative_examples;";
			}

			let improvementPoints = "";	
			for(let improvementPoint of feedbackFeature.improvementPoints){
				if (improvementPoints.length != 0) {
					improvementPoints += ",";
				}
				improvementPoints += improvementPoint;
			}
			ret[ret.length-1] += improvementPoints + ";";
		}
		if(header==undefined){
			header = tempHeader;
		}
	}
	return [header,ret];
}

function getFeedbackForFeature(feature, feedback){
	for(let feedbackFeature of feedback.feedbackFeature){
		if(feedbackFeature.key == feature){
			return feedbackFeature;
		}
	}
	return new FeedbackPerFeature(feature, -1, -1, [], []);
}

function getExamplesPerFeature(feature_key){
	let passExamples = [];
	let failExamples = [];
	FEATURES.forEach(
		element =>{
			if(element.key==feature_key){
				for(let example of element.fail_examples){
					failExamples.push(example.key);
				}
				for(let example of element.pass_examples){
					passExamples.push(example.key);
				}
				
			}
		}
	);
	return [passExamples, failExamples];
}

function findWeightForFeature(rubricSet, key){
	for(let i = 0; i < rubricSet.length; i++){
		let feature = rubricSet[i];
		if(feature.name==key){
			return feature.weight;
		}
	}
	return 0;
}

function handleExportButtonClick(){
	if(task==undefined){
		makeToast("Please select a task before trying to export one.");
	}
	else{
		// if there are "unsaved" changes, first save the current
		// data to the feedback set of the current task
		if (currentInputDirty()) {
			// make sure that the currently entered information is stored
			// in the current task
			// don't update the feedback text field
			var exitCode = summarizeFeedback(false);
			if (exitCode != OK) {
				// if the feedback could not be summarized
				// then stop exporting.
				makeToast("Please first fix the following: " + exitCode);
				return;
			}
		}
		try {
			var simpleFileName = task.course + "_" + task.name + "_" + localStorage.grader + "_" + localStorage.courseYear + "_" + localStorage.courseRun + "_feedback";
			var exportFormat = document.getElementById('export_format').value;
			if(exportFormat=="json"){
				const jsonString = JSON.stringify(task);
				download(simpleFileName+'.json', jsonString);
			}
			if(exportFormat=="csv"){
				//makeToast("CSV is not yet implemented");
				const csv = convertToCSV(task);
				download(simpleFileName+'.csv', csv);
			}
		} catch (err) {
			makeToast("Something went wrong: " + err);
		}
	}
}

function currentInputDirty() {
	var featureChanged = false;
	FEATURES.forEach(
    element => {
    		if (notEnteredInputs.get(element.key) != undefined) {
	    		featureChanged |= !notEnteredInputs.get(element.key).checked;
	    	}
    	});
	return featureChanged || textFieldsDirty;
}

function handleNextStudentButtonClick(){
	if(task!=undefined){
		if (!currentInputDirty()) {
			makeToast("No Data entered. Did not go to next student.");
			return;
		}

		// ensure that the currently filled in information
		// is stored in the task's feedback

		// do so without updating the text field for feedback
		var exitCode = summarizeFeedback(false);
		if (exitCode != OK) {
			// if the feedback could not be summarized
			// then stop exporting.
			makeToast("Please first fix the following: " + exitCode);
			return;
		}

		task.feedbackSet.push(undefined);
		localStorage.setItem('all_tasks', JSON.stringify(tasks));
		reset();
	}
	else{
		makeToast("You can not grade the next student if no task is selected.");
	}
}

function handleTextAreaClick(textarea, text){
	/* Select the text field */
	textarea.select();
	textarea.setSelectionRange(0, 99999); /* For mobile devices */

	/* Copy the text inside the text field */
	navigator.clipboard.writeText(textarea.value);

	/* Alert the copied text */
	makeToast('Copied '+text+' to clipboard!')
}


function handleDrop(e) {
  let dt = e.dataTransfer;
  let files = dt.files;

  handleFiles(files);
}

function handleFiles(files){
	var reader = new FileReader();
	reader.onload = function(){
		var dataURL = reader.result;
		var task = JSON.parse(dataURL);
		tasks.push(task);
		setTask(tasks.length - 1);
		updateTaskList();
		localStorage.setItem('all_tasks', JSON.stringify(tasks));
	};
	reader.readAsText(files[0]);
}

function handleToolTippToggle(){
	let checkbox = document.getElementById("tooltip_checkbox");
	let tableBody = document.getElementById("rubrics_table");
	if(checkbox.checked){
		tableBody.classList.remove("hideToolTipps");
		tableBody.classList.add("showToolTipps");
	}
	else{
		tableBody.classList.remove("showToolTipps");
		tableBody.classList.add("hideToolTipps");
	}
}

function preventDefaults (e) {
  e.preventDefault()
  e.stopPropagation()
}

function dropHandler(e) {

  e.stopPropagation();
  e.preventDefault();
  var files = e.dataTransfer.files; // Array of all files
}

function dragOverHandler(e) {
   e.stopPropagation();
   e.preventDefault();
   e.dataTransfer.dropEffect = 'copy';
}

function setTable(enabledFeatures, filter){
	var tableBody = document.getElementById('rubrics_table');
	tableBody.innerHTML = "";
	FEATURES.forEach(
    element => {
	  if(!filter||enabledFeatures.includes(element.key)){
      var tr = htmlToElement('<tr/>')
      tableBody.appendChild(tr);

      var th = htmlToElement(
        '<td class="first_col">' +
          element.name +
        '</td>');


      // row header
      const notEntered = htmlToElement(`<input type="hidden" checked name="${element.key}_not_entered" id="${element.key}_not_entered" value="true">`);
      notEnteredInputs.set(element.key, notEntered);
      th.appendChild(notEntered);

      const disabled = htmlToElement(`<input type="hidden" checked name="${element.key}_disabled" id="${element.key}_disabled" value="true">`);
      disabledInputs.set(element.key, disabled);
      th.appendChild(disabled);

      tr.appendChild(th);

      // negative examples
      appendExamples(tr, 'fail', element.key, element.fail_examples, failExInputs);

      // scores
      scoreDomElements = [];
      [1, 2, 3, 4].forEach( score => {
        const td = htmlToElement('<td/>');
        tr.appendChild(td);

        const div = htmlToElement('<div class="toggle-buttons together"/>');
        td.appendChild(div);

        const label = htmlToElement(`<label class="radio _${score}"/>`);

        div.appendChild(label);

        const input = htmlToElement(`<input type="radio" class="radio _${score}" name="${element.key}_score" value="${score}" id="${element.key}_score_${score}" onChange="scoreSet('${element.key}');">`);
        label.appendChild(input);
        label.appendChild(htmlToElement(score.toString()));

        scoreDomElements.push(input);
      });
	  scoreInputs.set(element.key, scoreDomElements);
      scoreInputs.first;

      // positive examples
      appendExamples(tr, 'pass', element.key, element.pass_examples, passExInputs);
	  }
    });
}

function scoreSet(feature) {
  notEnteredInputs.get(feature).checked = false;
  computePoints();
}

function computePointsPerFeature(feature){
	failExampleCount = failExInputs.get(feature).length;

	passExampleCount = passExInputs.get(feature).length;

	failExamplesSelected = 0;
	failExInputs.get(feature).forEach( domElement => {
		if (domElement.checked)
			failExamplesSelected++;
    });

	passExamplesSelected = 0;
	passExInputs.get(feature).forEach( domElement => {
		if (domElement.checked)
			passExamplesSelected++;
    });

	failRatio = failExamplesSelected / failExampleCount;
	if(isNaN(failRatio)){
		failRatio = 0;
	}

	passRatio = passExamplesSelected / passExampleCount;
	if(isNaN(passRatio)){
		passRatio = 0;
	}

	return Math.round(((passRatio - failRatio) + 1) * 2);
}

function examplesChange(feature) {
	let scoreInput = scoreInputs.get(feature);
	let computedScore = computePointsPerFeature(feature);
	let index = Math.min(computedScore, scoreInput.length-1);
	scoreInput[index].checked = true;

  notEnteredInputs.get(feature).checked = false;

	computePoints();
}

function computePoints(){
	if(task!=undefined){
		let score = computeWeightedScore();
		let extrapolatedPoints = computeExtrapolatedPoints(score);
		
		let pointbox = document.getElementById("task_calc_points");
		pointbox.value= extrapolatedPoints + ' (avg. wght. score: ' + score + ')';
	}
}

function computeExtrapolatedPoints(score) {
		let percentile = score / 3;
		return (Math.round(task.maxPoints * percentile * 2) / 2);
}

function computeWeightedScore() {
	let score = 0;
	let totalWeight = 0;
	for(let feature of task.rubricSet){
		unweightedFeatureScore = getScoreFromRadioButton(feature.name);
		score+=unweightedFeatureScore * feature.weight;
		totalWeight += feature.weight;
	}
	score/=totalWeight;
	return score;
}

function getScoreFromRadioButton(feature) {
	for (let i = 0; i < 4; i++) {
		if(scoreInputs.get(feature)[i].checked)
			return i;
	}
	return 0;
}

function handleApplyComputedPoints() {
	let score = computeWeightedScore();
	let extrapolatedPoints = computeExtrapolatedPoints(score);

	textFieldsDirty = true;

	document.getElementById('task_points').value = extrapolatedPoints;
}</script>	

	</head>
	<body onbeforeunload="return handleLeavePage()">
		<div class="minipageLeft">
			<h2>Select Task</h2>
			<div id="task_select" class="buttons" style="width:90%">
				<div id="selected_task">No tasks added</div>
				<ul id="task_list"></ul>
			</div>
		</div>
		<div class="minipageRight">
			<h2>Upload new Task</h2>
			<div class="buttons" style="width:90%">
				Create a new task by uploading corresponding file.
				<div id="fileDragOverField">
					<input type="file" id="input_file" onchange="handleFiles(this.files)">
						<label for="input_file">
							<strong style="cursor: pointer;">Choose a file</strong> or drag it here
						</label>
				</div>
			</div>
		</div>
		<table>
			<tr>
				<td style="vertical-align: top;">
					<h2>Grader</h2>
					<input type="text" id="grader_text" oninput="handleGraderChange()" />
				</td>
				<td style="vertical-align: top;">
					<h2>Course year</h2>
					<input type="text" id="course_year_text" oninput="handleCourseYearChange()" /><br/>
					<p>
						<i>
							Enter the year in which<br/>
							the course started with<br/>
							four digits (e.g., 2022).
						</i>
					</p>
				</td>
				<td style="vertical-align: top;">
					<h2>Course run</h2>
					<input type="text" id="course_run_text" oninput="handleCourseRunChange()" /><br/>
					<p>
						<i>
							If the course runs multiple<br/>
							times per year, enter the<br/>
							number of the run.<br/>
							Otherwise enter 1.
						</i>
					</p>
				</td>
			</tr>
		</table>
		<h2>Show Tooltipps</h2>
		<label>
			<input type="checkbox" onchange="handleToolTippToggle();" id="tooltip_checkbox"/>
			Toggle Tooltipps
		</label>
		<form>
			<div class="toggle-buttons together">
				<table width="100%" >
					<thead>
						<tr>
							<th scope="col">Feature</th>
							<th scope="col">Negative Examples</th>
							<th scope="col">
								1 - Fully<br>
								Failed
							</th>
							<th scope="col">
								2 - Partly<br>
								Failed
							</th>
							<th scope="col">
								3 - Partly<br>
								Satisfied
							</th>
							<th scope="col">
								4 - Fully<br>
								Satisfied
							</th>
							<th scope="col">Positive Examples</th>
						</tr>
					</thead>
					<tbody id='rubrics_table' class="showToolTipps">
		
					</tbody>
				</table>
				<div class="minipageTaskLeft">
					<h2>Achieved Points</h2>
					<input type="number" id='task_points' oninput="handleTextChange()"/>
					<button type="button" id='apply_computed_points' onclick="handleApplyComputedPoints()">Apply Computed</button>
				</div>
				<div class="minipageTaskLeft">
					<h2>Calculated Points</h2>
					<input type="text" id='task_calc_points' readonly/>
				</div>
				<div class="minipageTaskRight">
					<h2>Maximum Points</h2>
					<input type="text" id='task_max_points' readonly/>
				</div>
				<div style="cursor:pointer; clear:both;" onclick="handleFeedbackButtonClick()" class="buttons">
					Generate Feedback
				</div>

				<div class="minipageLeft">
					<div style="cursor:pointer" onclick="handleNextStudentButtonClick()" class="buttons">
						Next Student
					</div>
				</div>
				<div class="minipageRight">
					<div style="cursor:pointer" onclick="handleExportButtonClick()" class="buttons">
						Export all feedback for chosen task
					</div>
					Choose a format for exporting (default is JSON):<br>
					<select id="export_format">
						<option value="json">JSON-Format</option>
						<option value="csv">CSV-Format</option>
					</select>
				</div>
				<div class="minipageLeft">
					<h2>Additional Comment</h2>
					<textarea id='comment_text' cols="80" rows="10" onchange="handleTextChange()"></textarea>
				</div>
				<div class="minipageRight">
					<h2>Generated Feedback</h2>
					<textarea id='feedback_text' cols="80" rows="10" onclick="handleTextAreaClick(this, 'feedback')" readonly></textarea>
				</div>
			</div>
		</form>
	
		<div id="snackbar"> </div>
	</body>
</html>
